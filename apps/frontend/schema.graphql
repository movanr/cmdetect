schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false
  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]
  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean
  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String
  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]
  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String
  """does the column NOT match the given pattern"""
  _nlike: String
  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String
  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String
  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String
  """does the column match the given SQL regular expression"""
  _similar: String
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC
  """descending ordering of the cursor"""
  DESC
}

scalar inet

"""
Boolean expression to compare columns of type "inet". All fields are combined with logical 'AND'.
"""
input inet_comparison_exp {
  _eq: inet
  _gt: inet
  _gte: inet
  _in: [inet!]
  _is_null: Boolean
  _lt: inet
  _lte: inet
  _neq: inet
  _nin: [inet!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp
  """is the column contained in the given json value"""
  _contained_in: jsonb
  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  """does the string exist as a top-level key in the column"""
  _has_key: String
  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]
  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "organization"
  """
  delete_organization(
    """filter the rows which have to be deleted"""
    where: organization_bool_exp!
  ): organization_mutation_response
  """
  delete single row from the table: "organization"
  """
  delete_organization_by_pk(id: uuid!): organization
  """
  delete data from the table: "patient"
  """
  delete_patient(
    """filter the rows which have to be deleted"""
    where: patient_bool_exp!
  ): patient_mutation_response
  """
  delete single row from the table: "patient"
  """
  delete_patient_by_pk(id: uuid!): patient
  """
  delete data from the table: "patient_consent"
  """
  delete_patient_consent(
    """filter the rows which have to be deleted"""
    where: patient_consent_bool_exp!
  ): patient_consent_mutation_response
  """
  delete single row from the table: "patient_consent"
  """
  delete_patient_consent_by_pk(id: uuid!): patient_consent
  """
  delete data from the table: "patient_record"
  """
  delete_patient_record(
    """filter the rows which have to be deleted"""
    where: patient_record_bool_exp!
  ): patient_record_mutation_response
  """
  delete single row from the table: "patient_record"
  """
  delete_patient_record_by_pk(id: uuid!): patient_record
  """
  delete data from the table: "questionnaire_response"
  """
  delete_questionnaire_response(
    """filter the rows which have to be deleted"""
    where: questionnaire_response_bool_exp!
  ): questionnaire_response_mutation_response
  """
  delete single row from the table: "questionnaire_response"
  """
  delete_questionnaire_response_by_pk(id: uuid!): questionnaire_response
  """
  delete data from the table: "user"
  """
  delete_user(
    """filter the rows which have to be deleted"""
    where: user_bool_exp!
  ): user_mutation_response
  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(id: String!): user
  """
  insert data into the table: "organization"
  """
  insert_organization(
    """the rows to be inserted"""
    objects: [organization_insert_input!]!
    """upsert condition"""
    on_conflict: organization_on_conflict
  ): organization_mutation_response
  """
  insert a single row into the table: "organization"
  """
  insert_organization_one(
    """the row to be inserted"""
    object: organization_insert_input!
    """upsert condition"""
    on_conflict: organization_on_conflict
  ): organization
  """
  insert data into the table: "patient"
  """
  insert_patient(
    """the rows to be inserted"""
    objects: [patient_insert_input!]!
    """upsert condition"""
    on_conflict: patient_on_conflict
  ): patient_mutation_response
  """
  insert data into the table: "patient_consent"
  """
  insert_patient_consent(
    """the rows to be inserted"""
    objects: [patient_consent_insert_input!]!
    """upsert condition"""
    on_conflict: patient_consent_on_conflict
  ): patient_consent_mutation_response
  """
  insert a single row into the table: "patient_consent"
  """
  insert_patient_consent_one(
    """the row to be inserted"""
    object: patient_consent_insert_input!
    """upsert condition"""
    on_conflict: patient_consent_on_conflict
  ): patient_consent
  """
  insert a single row into the table: "patient"
  """
  insert_patient_one(
    """the row to be inserted"""
    object: patient_insert_input!
    """upsert condition"""
    on_conflict: patient_on_conflict
  ): patient
  """
  insert data into the table: "patient_record"
  """
  insert_patient_record(
    """the rows to be inserted"""
    objects: [patient_record_insert_input!]!
    """upsert condition"""
    on_conflict: patient_record_on_conflict
  ): patient_record_mutation_response
  """
  insert a single row into the table: "patient_record"
  """
  insert_patient_record_one(
    """the row to be inserted"""
    object: patient_record_insert_input!
    """upsert condition"""
    on_conflict: patient_record_on_conflict
  ): patient_record
  """
  insert data into the table: "questionnaire_response"
  """
  insert_questionnaire_response(
    """the rows to be inserted"""
    objects: [questionnaire_response_insert_input!]!
    """upsert condition"""
    on_conflict: questionnaire_response_on_conflict
  ): questionnaire_response_mutation_response
  """
  insert a single row into the table: "questionnaire_response"
  """
  insert_questionnaire_response_one(
    """the row to be inserted"""
    object: questionnaire_response_insert_input!
    """upsert condition"""
    on_conflict: questionnaire_response_on_conflict
  ): questionnaire_response
  """
  insert data into the table: "user"
  """
  insert_user(
    """the rows to be inserted"""
    objects: [user_insert_input!]!
    """upsert condition"""
    on_conflict: user_on_conflict
  ): user_mutation_response
  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """the row to be inserted"""
    object: user_insert_input!
    """upsert condition"""
    on_conflict: user_on_conflict
  ): user
  """
  update data of the table: "organization"
  """
  update_organization(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_set_input
    """filter the rows which have to be updated"""
    where: organization_bool_exp!
  ): organization_mutation_response
  """
  update single row of the table: "organization"
  """
  update_organization_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_set_input
    pk_columns: organization_pk_columns_input!
  ): organization
  """
  update multiples rows of table: "organization"
  """
  update_organization_many(
    """updates to execute, in order"""
    updates: [organization_updates!]!
  ): [organization_mutation_response]
  """
  update data of the table: "patient"
  """
  update_patient(
    """sets the columns of the filtered rows to the given values"""
    _set: patient_set_input
    """filter the rows which have to be updated"""
    where: patient_bool_exp!
  ): patient_mutation_response
  """
  update single row of the table: "patient"
  """
  update_patient_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: patient_set_input
    pk_columns: patient_pk_columns_input!
  ): patient
  """
  update data of the table: "patient_consent"
  """
  update_patient_consent(
    """sets the columns of the filtered rows to the given values"""
    _set: patient_consent_set_input
    """filter the rows which have to be updated"""
    where: patient_consent_bool_exp!
  ): patient_consent_mutation_response
  """
  update single row of the table: "patient_consent"
  """
  update_patient_consent_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: patient_consent_set_input
    pk_columns: patient_consent_pk_columns_input!
  ): patient_consent
  """
  update multiples rows of table: "patient_consent"
  """
  update_patient_consent_many(
    """updates to execute, in order"""
    updates: [patient_consent_updates!]!
  ): [patient_consent_mutation_response]
  """
  update multiples rows of table: "patient"
  """
  update_patient_many(
    """updates to execute, in order"""
    updates: [patient_updates!]!
  ): [patient_mutation_response]
  """
  update data of the table: "patient_record"
  """
  update_patient_record(
    """sets the columns of the filtered rows to the given values"""
    _set: patient_record_set_input
    """filter the rows which have to be updated"""
    where: patient_record_bool_exp!
  ): patient_record_mutation_response
  """
  update single row of the table: "patient_record"
  """
  update_patient_record_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: patient_record_set_input
    pk_columns: patient_record_pk_columns_input!
  ): patient_record
  """
  update multiples rows of table: "patient_record"
  """
  update_patient_record_many(
    """updates to execute, in order"""
    updates: [patient_record_updates!]!
  ): [patient_record_mutation_response]
  """
  update data of the table: "questionnaire_response"
  """
  update_questionnaire_response(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: questionnaire_response_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: questionnaire_response_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: questionnaire_response_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: questionnaire_response_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: questionnaire_response_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: questionnaire_response_set_input
    """filter the rows which have to be updated"""
    where: questionnaire_response_bool_exp!
  ): questionnaire_response_mutation_response
  """
  update single row of the table: "questionnaire_response"
  """
  update_questionnaire_response_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: questionnaire_response_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: questionnaire_response_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: questionnaire_response_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: questionnaire_response_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: questionnaire_response_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: questionnaire_response_set_input
    pk_columns: questionnaire_response_pk_columns_input!
  ): questionnaire_response
  """
  update multiples rows of table: "questionnaire_response"
  """
  update_questionnaire_response_many(
    """updates to execute, in order"""
    updates: [questionnaire_response_updates!]!
  ): [questionnaire_response_mutation_response]
  """
  update data of the table: "user"
  """
  update_user(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: user_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: user_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: user_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: user_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: user_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response
  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: user_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: user_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: user_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: user_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: user_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user
  """
  update multiples rows of table: "user"
  """
  update_user_many(
    """updates to execute, in order"""
    updates: [user_updates!]!
  ): [user_mutation_response]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc
  """in ascending order, nulls first"""
  asc_nulls_first
  """in ascending order, nulls last"""
  asc_nulls_last
  """in descending order, nulls first"""
  desc
  """in descending order, nulls first"""
  desc_nulls_first
  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "organization"
"""
type organization {
  address_line1: String
  address_line2: String
  city: String
  country: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  id: uuid!
  name: String!
  """An array relationship"""
  patient_consents(
    """distinct select on columns"""
    distinct_on: [patient_consent_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_consent_order_by!]
    """filter the rows returned"""
    where: patient_consent_bool_exp
  ): [patient_consent!]!
  """An aggregate relationship"""
  patient_consents_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_consent_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_consent_order_by!]
    """filter the rows returned"""
    where: patient_consent_bool_exp
  ): patient_consent_aggregate!
  """An array relationship"""
  patient_records(
    """distinct select on columns"""
    distinct_on: [patient_record_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_record_order_by!]
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): [patient_record!]!
  """An aggregate relationship"""
  patient_records_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_record_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_record_order_by!]
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): patient_record_aggregate!
  """An array relationship"""
  patients(
    """distinct select on columns"""
    distinct_on: [patient_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_order_by!]
    """filter the rows returned"""
    where: patient_bool_exp
  ): [patient!]!
  """An aggregate relationship"""
  patients_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_order_by!]
    """filter the rows returned"""
    where: patient_bool_exp
  ): patient_aggregate!
  phone: String
  postal_code: String
  """An array relationship"""
  questionnaire_responses(
    """distinct select on columns"""
    distinct_on: [questionnaire_response_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [questionnaire_response_order_by!]
    """filter the rows returned"""
    where: questionnaire_response_bool_exp
  ): [questionnaire_response!]!
  """An aggregate relationship"""
  questionnaire_responses_aggregate(
    """distinct select on columns"""
    distinct_on: [questionnaire_response_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [questionnaire_response_order_by!]
    """filter the rows returned"""
    where: questionnaire_response_bool_exp
  ): questionnaire_response_aggregate!
  updated_at: timestamptz
  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [user_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [user_order_by!]
    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!
  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [user_order_by!]
    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!
  website: String
}

"""
aggregated selection of "organization"
"""
type organization_aggregate {
  aggregate: organization_aggregate_fields
  nodes: [organization!]!
}

"""
aggregate fields of "organization"
"""
type organization_aggregate_fields {
  count(columns: [organization_select_column!], distinct: Boolean): Int!
  max: organization_max_fields
  min: organization_min_fields
}

"""
Boolean expression to filter rows from the table "organization". All fields are combined with a logical 'AND'.
"""
input organization_bool_exp {
  _and: [organization_bool_exp!]
  _not: organization_bool_exp
  _or: [organization_bool_exp!]
  address_line1: String_comparison_exp
  address_line2: String_comparison_exp
  city: String_comparison_exp
  country: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  patient_consents: patient_consent_bool_exp
  patient_consents_aggregate: patient_consent_aggregate_bool_exp
  patient_records: patient_record_bool_exp
  patient_records_aggregate: patient_record_aggregate_bool_exp
  patients: patient_bool_exp
  patients_aggregate: patient_aggregate_bool_exp
  phone: String_comparison_exp
  postal_code: String_comparison_exp
  questionnaire_responses: questionnaire_response_bool_exp
  questionnaire_responses_aggregate: questionnaire_response_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  users: user_bool_exp
  users_aggregate: user_aggregate_bool_exp
  website: String_comparison_exp
}

"""
unique or primary key constraints on table "organization"
"""
enum organization_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  organization_pkey
}

"""
input type for inserting data into table "organization"
"""
input organization_insert_input {
  address_line1: String
  address_line2: String
  city: String
  country: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  id: uuid
  name: String
  patient_consents: patient_consent_arr_rel_insert_input
  patient_records: patient_record_arr_rel_insert_input
  patients: patient_arr_rel_insert_input
  phone: String
  postal_code: String
  questionnaire_responses: questionnaire_response_arr_rel_insert_input
  updated_at: timestamptz
  users: user_arr_rel_insert_input
  website: String
}

"""aggregate max on columns"""
type organization_max_fields {
  address_line1: String
  address_line2: String
  city: String
  country: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  id: uuid
  name: String
  phone: String
  postal_code: String
  updated_at: timestamptz
  website: String
}

"""aggregate min on columns"""
type organization_min_fields {
  address_line1: String
  address_line2: String
  city: String
  country: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  id: uuid
  name: String
  phone: String
  postal_code: String
  updated_at: timestamptz
  website: String
}

"""
response of any mutation on the table "organization"
"""
type organization_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [organization!]!
}

"""
input type for inserting object relation for remote table "organization"
"""
input organization_obj_rel_insert_input {
  data: organization_insert_input!
  """upsert condition"""
  on_conflict: organization_on_conflict
}

"""
on_conflict condition type for table "organization"
"""
input organization_on_conflict {
  constraint: organization_constraint!
  update_columns: [organization_update_column!]! = []
  where: organization_bool_exp
}

"""Ordering options when selecting data from "organization"."""
input organization_order_by {
  address_line1: order_by
  address_line2: order_by
  city: order_by
  country: order_by
  created_at: order_by
  deleted_at: order_by
  email: order_by
  id: order_by
  name: order_by
  patient_consents_aggregate: patient_consent_aggregate_order_by
  patient_records_aggregate: patient_record_aggregate_order_by
  patients_aggregate: patient_aggregate_order_by
  phone: order_by
  postal_code: order_by
  questionnaire_responses_aggregate: questionnaire_response_aggregate_order_by
  updated_at: order_by
  users_aggregate: user_aggregate_order_by
  website: order_by
}

"""primary key columns input for table: organization"""
input organization_pk_columns_input {
  id: uuid!
}

"""
select columns of table "organization"
"""
enum organization_select_column {
  """column name"""
  address_line1
  """column name"""
  address_line2
  """column name"""
  city
  """column name"""
  country
  """column name"""
  created_at
  """column name"""
  deleted_at
  """column name"""
  email
  """column name"""
  id
  """column name"""
  name
  """column name"""
  phone
  """column name"""
  postal_code
  """column name"""
  updated_at
  """column name"""
  website
}

"""
input type for updating data in table "organization"
"""
input organization_set_input {
  address_line1: String
  address_line2: String
  city: String
  country: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  id: uuid
  name: String
  phone: String
  postal_code: String
  updated_at: timestamptz
  website: String
}

"""
Streaming cursor of the table "organization"
"""
input organization_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: organization_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input organization_stream_cursor_value_input {
  address_line1: String
  address_line2: String
  city: String
  country: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  id: uuid
  name: String
  phone: String
  postal_code: String
  updated_at: timestamptz
  website: String
}

"""
update columns of table "organization"
"""
enum organization_update_column {
  """column name"""
  address_line1
  """column name"""
  address_line2
  """column name"""
  city
  """column name"""
  country
  """column name"""
  created_at
  """column name"""
  deleted_at
  """column name"""
  email
  """column name"""
  id
  """column name"""
  name
  """column name"""
  phone
  """column name"""
  postal_code
  """column name"""
  updated_at
  """column name"""
  website
}

input organization_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: organization_set_input
  """filter the rows which have to be updated"""
  where: organization_bool_exp!
}

"""
columns and relationships of "patient"
"""
type patient {
  clinic_internal_id: String!
  created_at: timestamptz
  date_of_birth_encrypted: String
  deleted_at: timestamptz
  first_name_encrypted: String!
  gender_encrypted: String
  id: uuid!
  last_name_encrypted: String!
  """An object relationship"""
  organization: organization!
  organization_id: uuid!
  """An array relationship"""
  patient_records(
    """distinct select on columns"""
    distinct_on: [patient_record_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_record_order_by!]
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): [patient_record!]!
  """An aggregate relationship"""
  patient_records_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_record_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_record_order_by!]
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): patient_record_aggregate!
  updated_at: timestamptz
}

"""
aggregated selection of "patient"
"""
type patient_aggregate {
  aggregate: patient_aggregate_fields
  nodes: [patient!]!
}

input patient_aggregate_bool_exp {
  count: patient_aggregate_bool_exp_count
}

input patient_aggregate_bool_exp_count {
  arguments: [patient_select_column!]
  distinct: Boolean
  filter: patient_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "patient"
"""
type patient_aggregate_fields {
  count(columns: [patient_select_column!], distinct: Boolean): Int!
  max: patient_max_fields
  min: patient_min_fields
}

"""
order by aggregate values of table "patient"
"""
input patient_aggregate_order_by {
  count: order_by
  max: patient_max_order_by
  min: patient_min_order_by
}

"""
input type for inserting array relation for remote table "patient"
"""
input patient_arr_rel_insert_input {
  data: [patient_insert_input!]!
  """upsert condition"""
  on_conflict: patient_on_conflict
}

"""
Boolean expression to filter rows from the table "patient". All fields are combined with a logical 'AND'.
"""
input patient_bool_exp {
  _and: [patient_bool_exp!]
  _not: patient_bool_exp
  _or: [patient_bool_exp!]
  clinic_internal_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  date_of_birth_encrypted: String_comparison_exp
  deleted_at: timestamptz_comparison_exp
  first_name_encrypted: String_comparison_exp
  gender_encrypted: String_comparison_exp
  id: uuid_comparison_exp
  last_name_encrypted: String_comparison_exp
  organization: organization_bool_exp
  organization_id: uuid_comparison_exp
  patient_records: patient_record_bool_exp
  patient_records_aggregate: patient_record_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
columns and relationships of "patient_consent"
"""
type patient_consent {
  consent_given: Boolean!
  consent_text: String!
  consent_version: String!
  consented_at: timestamptz!
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid!
  ip_address: inet
  """An object relationship"""
  organization: organization!
  organization_id: uuid!
  """An object relationship"""
  patient_record: patient_record!
  patient_record_id: uuid!
  """An array relationship"""
  questionnaire_responses(
    """distinct select on columns"""
    distinct_on: [questionnaire_response_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [questionnaire_response_order_by!]
    """filter the rows returned"""
    where: questionnaire_response_bool_exp
  ): [questionnaire_response!]!
  """An aggregate relationship"""
  questionnaire_responses_aggregate(
    """distinct select on columns"""
    distinct_on: [questionnaire_response_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [questionnaire_response_order_by!]
    """filter the rows returned"""
    where: questionnaire_response_bool_exp
  ): questionnaire_response_aggregate!
  updated_at: timestamptz
  user_agent: String
}

"""
aggregated selection of "patient_consent"
"""
type patient_consent_aggregate {
  aggregate: patient_consent_aggregate_fields
  nodes: [patient_consent!]!
}

input patient_consent_aggregate_bool_exp {
  bool_and: patient_consent_aggregate_bool_exp_bool_and
  bool_or: patient_consent_aggregate_bool_exp_bool_or
  count: patient_consent_aggregate_bool_exp_count
}

input patient_consent_aggregate_bool_exp_bool_and {
  arguments: patient_consent_select_column_patient_consent_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: patient_consent_bool_exp
  predicate: Boolean_comparison_exp!
}

input patient_consent_aggregate_bool_exp_bool_or {
  arguments: patient_consent_select_column_patient_consent_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: patient_consent_bool_exp
  predicate: Boolean_comparison_exp!
}

input patient_consent_aggregate_bool_exp_count {
  arguments: [patient_consent_select_column!]
  distinct: Boolean
  filter: patient_consent_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "patient_consent"
"""
type patient_consent_aggregate_fields {
  count(columns: [patient_consent_select_column!], distinct: Boolean): Int!
  max: patient_consent_max_fields
  min: patient_consent_min_fields
}

"""
order by aggregate values of table "patient_consent"
"""
input patient_consent_aggregate_order_by {
  count: order_by
  max: patient_consent_max_order_by
  min: patient_consent_min_order_by
}

"""
input type for inserting array relation for remote table "patient_consent"
"""
input patient_consent_arr_rel_insert_input {
  data: [patient_consent_insert_input!]!
  """upsert condition"""
  on_conflict: patient_consent_on_conflict
}

"""
Boolean expression to filter rows from the table "patient_consent". All fields are combined with a logical 'AND'.
"""
input patient_consent_bool_exp {
  _and: [patient_consent_bool_exp!]
  _not: patient_consent_bool_exp
  _or: [patient_consent_bool_exp!]
  consent_given: Boolean_comparison_exp
  consent_text: String_comparison_exp
  consent_version: String_comparison_exp
  consented_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  ip_address: inet_comparison_exp
  organization: organization_bool_exp
  organization_id: uuid_comparison_exp
  patient_record: patient_record_bool_exp
  patient_record_id: uuid_comparison_exp
  questionnaire_responses: questionnaire_response_bool_exp
  questionnaire_responses_aggregate: questionnaire_response_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  user_agent: String_comparison_exp
}

"""
unique or primary key constraints on table "patient_consent"
"""
enum patient_consent_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  patient_consent_pkey
  """
  unique or primary key constraint on columns "patient_record_id"
  """
  uk_consent_per_record
}

"""
input type for inserting data into table "patient_consent"
"""
input patient_consent_insert_input {
  consent_given: Boolean
  consent_text: String
  consent_version: String
  consented_at: timestamptz
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  ip_address: inet
  organization: organization_obj_rel_insert_input
  organization_id: uuid
  patient_record: patient_record_obj_rel_insert_input
  patient_record_id: uuid
  questionnaire_responses: questionnaire_response_arr_rel_insert_input
  updated_at: timestamptz
  user_agent: String
}

"""aggregate max on columns"""
type patient_consent_max_fields {
  consent_text: String
  consent_version: String
  consented_at: timestamptz
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  organization_id: uuid
  patient_record_id: uuid
  updated_at: timestamptz
  user_agent: String
}

"""
order by max() on columns of table "patient_consent"
"""
input patient_consent_max_order_by {
  consent_text: order_by
  consent_version: order_by
  consented_at: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  organization_id: order_by
  patient_record_id: order_by
  updated_at: order_by
  user_agent: order_by
}

"""aggregate min on columns"""
type patient_consent_min_fields {
  consent_text: String
  consent_version: String
  consented_at: timestamptz
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  organization_id: uuid
  patient_record_id: uuid
  updated_at: timestamptz
  user_agent: String
}

"""
order by min() on columns of table "patient_consent"
"""
input patient_consent_min_order_by {
  consent_text: order_by
  consent_version: order_by
  consented_at: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  organization_id: order_by
  patient_record_id: order_by
  updated_at: order_by
  user_agent: order_by
}

"""
response of any mutation on the table "patient_consent"
"""
type patient_consent_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [patient_consent!]!
}

"""
input type for inserting object relation for remote table "patient_consent"
"""
input patient_consent_obj_rel_insert_input {
  data: patient_consent_insert_input!
  """upsert condition"""
  on_conflict: patient_consent_on_conflict
}

"""
on_conflict condition type for table "patient_consent"
"""
input patient_consent_on_conflict {
  constraint: patient_consent_constraint!
  update_columns: [patient_consent_update_column!]! = []
  where: patient_consent_bool_exp
}

"""Ordering options when selecting data from "patient_consent"."""
input patient_consent_order_by {
  consent_given: order_by
  consent_text: order_by
  consent_version: order_by
  consented_at: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  ip_address: order_by
  organization: organization_order_by
  organization_id: order_by
  patient_record: patient_record_order_by
  patient_record_id: order_by
  questionnaire_responses_aggregate: questionnaire_response_aggregate_order_by
  updated_at: order_by
  user_agent: order_by
}

"""primary key columns input for table: patient_consent"""
input patient_consent_pk_columns_input {
  id: uuid!
}

"""
select columns of table "patient_consent"
"""
enum patient_consent_select_column {
  """column name"""
  consent_given
  """column name"""
  consent_text
  """column name"""
  consent_version
  """column name"""
  consented_at
  """column name"""
  created_at
  """column name"""
  deleted_at
  """column name"""
  id
  """column name"""
  ip_address
  """column name"""
  organization_id
  """column name"""
  patient_record_id
  """column name"""
  updated_at
  """column name"""
  user_agent
}

"""
select "patient_consent_aggregate_bool_exp_bool_and_arguments_columns" columns of table "patient_consent"
"""
enum patient_consent_select_column_patient_consent_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  consent_given
}

"""
select "patient_consent_aggregate_bool_exp_bool_or_arguments_columns" columns of table "patient_consent"
"""
enum patient_consent_select_column_patient_consent_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  consent_given
}

"""
input type for updating data in table "patient_consent"
"""
input patient_consent_set_input {
  consent_given: Boolean
  consent_text: String
  consent_version: String
  consented_at: timestamptz
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  ip_address: inet
  organization_id: uuid
  patient_record_id: uuid
  updated_at: timestamptz
  user_agent: String
}

"""
Streaming cursor of the table "patient_consent"
"""
input patient_consent_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: patient_consent_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input patient_consent_stream_cursor_value_input {
  consent_given: Boolean
  consent_text: String
  consent_version: String
  consented_at: timestamptz
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  ip_address: inet
  organization_id: uuid
  patient_record_id: uuid
  updated_at: timestamptz
  user_agent: String
}

"""
update columns of table "patient_consent"
"""
enum patient_consent_update_column {
  """column name"""
  consent_given
  """column name"""
  consent_text
  """column name"""
  consent_version
  """column name"""
  consented_at
  """column name"""
  created_at
  """column name"""
  deleted_at
  """column name"""
  id
  """column name"""
  ip_address
  """column name"""
  organization_id
  """column name"""
  patient_record_id
  """column name"""
  updated_at
  """column name"""
  user_agent
}

input patient_consent_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: patient_consent_set_input
  """filter the rows which have to be updated"""
  where: patient_consent_bool_exp!
}

"""
unique or primary key constraints on table "patient"
"""
enum patient_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  patient_pkey
  """
  unique or primary key constraint on columns "organization_id", "clinic_internal_id"
  """
  uk_patient_clinic_id_org
}

"""
input type for inserting data into table "patient"
"""
input patient_insert_input {
  clinic_internal_id: String
  created_at: timestamptz
  date_of_birth_encrypted: String
  deleted_at: timestamptz
  first_name_encrypted: String
  gender_encrypted: String
  id: uuid
  last_name_encrypted: String
  organization: organization_obj_rel_insert_input
  organization_id: uuid
  patient_records: patient_record_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type patient_max_fields {
  clinic_internal_id: String
  created_at: timestamptz
  date_of_birth_encrypted: String
  deleted_at: timestamptz
  first_name_encrypted: String
  gender_encrypted: String
  id: uuid
  last_name_encrypted: String
  organization_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "patient"
"""
input patient_max_order_by {
  clinic_internal_id: order_by
  created_at: order_by
  date_of_birth_encrypted: order_by
  deleted_at: order_by
  first_name_encrypted: order_by
  gender_encrypted: order_by
  id: order_by
  last_name_encrypted: order_by
  organization_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type patient_min_fields {
  clinic_internal_id: String
  created_at: timestamptz
  date_of_birth_encrypted: String
  deleted_at: timestamptz
  first_name_encrypted: String
  gender_encrypted: String
  id: uuid
  last_name_encrypted: String
  organization_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "patient"
"""
input patient_min_order_by {
  clinic_internal_id: order_by
  created_at: order_by
  date_of_birth_encrypted: order_by
  deleted_at: order_by
  first_name_encrypted: order_by
  gender_encrypted: order_by
  id: order_by
  last_name_encrypted: order_by
  organization_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "patient"
"""
type patient_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [patient!]!
}

"""
input type for inserting object relation for remote table "patient"
"""
input patient_obj_rel_insert_input {
  data: patient_insert_input!
  """upsert condition"""
  on_conflict: patient_on_conflict
}

"""
on_conflict condition type for table "patient"
"""
input patient_on_conflict {
  constraint: patient_constraint!
  update_columns: [patient_update_column!]! = []
  where: patient_bool_exp
}

"""Ordering options when selecting data from "patient"."""
input patient_order_by {
  clinic_internal_id: order_by
  created_at: order_by
  date_of_birth_encrypted: order_by
  deleted_at: order_by
  first_name_encrypted: order_by
  gender_encrypted: order_by
  id: order_by
  last_name_encrypted: order_by
  organization: organization_order_by
  organization_id: order_by
  patient_records_aggregate: patient_record_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: patient"""
input patient_pk_columns_input {
  id: uuid!
}

"""
columns and relationships of "patient_record"
"""
type patient_record {
  assigned_to: uuid!
  created_at: timestamptz
  created_by: uuid!
  deleted_at: timestamptz
  first_viewed_at: timestamptz
  first_viewed_by: uuid
  id: uuid!
  invite_expires_at: timestamptz
  invite_status: String
  invite_token: uuid
  last_activity_at: timestamptz
  last_activity_by: uuid
  notes: String
  """An object relationship"""
  organization: organization!
  organization_id: uuid!
  """An object relationship"""
  patient: patient!
  """An object relationship"""
  patient_consent: patient_consent
  patient_id: uuid!
  """An array relationship"""
  questionnaire_responses(
    """distinct select on columns"""
    distinct_on: [questionnaire_response_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [questionnaire_response_order_by!]
    """filter the rows returned"""
    where: questionnaire_response_bool_exp
  ): [questionnaire_response!]!
  """An aggregate relationship"""
  questionnaire_responses_aggregate(
    """distinct select on columns"""
    distinct_on: [questionnaire_response_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [questionnaire_response_order_by!]
    """filter the rows returned"""
    where: questionnaire_response_bool_exp
  ): questionnaire_response_aggregate!
  updated_at: timestamptz
  """An object relationship"""
  user: user!
  """An object relationship"""
  userByCreatedBy: user!
  """An object relationship"""
  userByFirstViewedBy: user
  """An object relationship"""
  userByLastActivityBy: user
  workflow_status: String
}

"""
aggregated selection of "patient_record"
"""
type patient_record_aggregate {
  aggregate: patient_record_aggregate_fields
  nodes: [patient_record!]!
}

input patient_record_aggregate_bool_exp {
  count: patient_record_aggregate_bool_exp_count
}

input patient_record_aggregate_bool_exp_count {
  arguments: [patient_record_select_column!]
  distinct: Boolean
  filter: patient_record_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "patient_record"
"""
type patient_record_aggregate_fields {
  count(columns: [patient_record_select_column!], distinct: Boolean): Int!
  max: patient_record_max_fields
  min: patient_record_min_fields
}

"""
order by aggregate values of table "patient_record"
"""
input patient_record_aggregate_order_by {
  count: order_by
  max: patient_record_max_order_by
  min: patient_record_min_order_by
}

"""
input type for inserting array relation for remote table "patient_record"
"""
input patient_record_arr_rel_insert_input {
  data: [patient_record_insert_input!]!
  """upsert condition"""
  on_conflict: patient_record_on_conflict
}

"""
Boolean expression to filter rows from the table "patient_record". All fields are combined with a logical 'AND'.
"""
input patient_record_bool_exp {
  _and: [patient_record_bool_exp!]
  _not: patient_record_bool_exp
  _or: [patient_record_bool_exp!]
  assigned_to: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by: uuid_comparison_exp
  deleted_at: timestamptz_comparison_exp
  first_viewed_at: timestamptz_comparison_exp
  first_viewed_by: uuid_comparison_exp
  id: uuid_comparison_exp
  invite_expires_at: timestamptz_comparison_exp
  invite_status: String_comparison_exp
  invite_token: uuid_comparison_exp
  last_activity_at: timestamptz_comparison_exp
  last_activity_by: uuid_comparison_exp
  notes: String_comparison_exp
  organization: organization_bool_exp
  organization_id: uuid_comparison_exp
  patient: patient_bool_exp
  patient_consent: patient_consent_bool_exp
  patient_id: uuid_comparison_exp
  questionnaire_responses: questionnaire_response_bool_exp
  questionnaire_responses_aggregate: questionnaire_response_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  userByCreatedBy: user_bool_exp
  userByFirstViewedBy: user_bool_exp
  userByLastActivityBy: user_bool_exp
  workflow_status: String_comparison_exp
}

"""
unique or primary key constraints on table "patient_record"
"""
enum patient_record_constraint {
  """
  unique or primary key constraint on columns "invite_token"
  """
  idx_record_invite_token
  """
  unique or primary key constraint on columns "id"
  """
  patient_record_pkey
}

"""
input type for inserting data into table "patient_record"
"""
input patient_record_insert_input {
  assigned_to: uuid
  created_at: timestamptz
  created_by: uuid
  deleted_at: timestamptz
  first_viewed_at: timestamptz
  first_viewed_by: uuid
  id: uuid
  invite_expires_at: timestamptz
  invite_status: String
  invite_token: uuid
  last_activity_at: timestamptz
  last_activity_by: uuid
  notes: String
  organization: organization_obj_rel_insert_input
  organization_id: uuid
  patient: patient_obj_rel_insert_input
  patient_consent: patient_consent_obj_rel_insert_input
  patient_id: uuid
  questionnaire_responses: questionnaire_response_arr_rel_insert_input
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  userByCreatedBy: user_obj_rel_insert_input
  userByFirstViewedBy: user_obj_rel_insert_input
  userByLastActivityBy: user_obj_rel_insert_input
  workflow_status: String
}

"""aggregate max on columns"""
type patient_record_max_fields {
  assigned_to: uuid
  created_at: timestamptz
  created_by: uuid
  deleted_at: timestamptz
  first_viewed_at: timestamptz
  first_viewed_by: uuid
  id: uuid
  invite_expires_at: timestamptz
  invite_status: String
  invite_token: uuid
  last_activity_at: timestamptz
  last_activity_by: uuid
  notes: String
  organization_id: uuid
  patient_id: uuid
  updated_at: timestamptz
  workflow_status: String
}

"""
order by max() on columns of table "patient_record"
"""
input patient_record_max_order_by {
  assigned_to: order_by
  created_at: order_by
  created_by: order_by
  deleted_at: order_by
  first_viewed_at: order_by
  first_viewed_by: order_by
  id: order_by
  invite_expires_at: order_by
  invite_status: order_by
  invite_token: order_by
  last_activity_at: order_by
  last_activity_by: order_by
  notes: order_by
  organization_id: order_by
  patient_id: order_by
  updated_at: order_by
  workflow_status: order_by
}

"""aggregate min on columns"""
type patient_record_min_fields {
  assigned_to: uuid
  created_at: timestamptz
  created_by: uuid
  deleted_at: timestamptz
  first_viewed_at: timestamptz
  first_viewed_by: uuid
  id: uuid
  invite_expires_at: timestamptz
  invite_status: String
  invite_token: uuid
  last_activity_at: timestamptz
  last_activity_by: uuid
  notes: String
  organization_id: uuid
  patient_id: uuid
  updated_at: timestamptz
  workflow_status: String
}

"""
order by min() on columns of table "patient_record"
"""
input patient_record_min_order_by {
  assigned_to: order_by
  created_at: order_by
  created_by: order_by
  deleted_at: order_by
  first_viewed_at: order_by
  first_viewed_by: order_by
  id: order_by
  invite_expires_at: order_by
  invite_status: order_by
  invite_token: order_by
  last_activity_at: order_by
  last_activity_by: order_by
  notes: order_by
  organization_id: order_by
  patient_id: order_by
  updated_at: order_by
  workflow_status: order_by
}

"""
response of any mutation on the table "patient_record"
"""
type patient_record_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [patient_record!]!
}

"""
input type for inserting object relation for remote table "patient_record"
"""
input patient_record_obj_rel_insert_input {
  data: patient_record_insert_input!
  """upsert condition"""
  on_conflict: patient_record_on_conflict
}

"""
on_conflict condition type for table "patient_record"
"""
input patient_record_on_conflict {
  constraint: patient_record_constraint!
  update_columns: [patient_record_update_column!]! = []
  where: patient_record_bool_exp
}

"""Ordering options when selecting data from "patient_record"."""
input patient_record_order_by {
  assigned_to: order_by
  created_at: order_by
  created_by: order_by
  deleted_at: order_by
  first_viewed_at: order_by
  first_viewed_by: order_by
  id: order_by
  invite_expires_at: order_by
  invite_status: order_by
  invite_token: order_by
  last_activity_at: order_by
  last_activity_by: order_by
  notes: order_by
  organization: organization_order_by
  organization_id: order_by
  patient: patient_order_by
  patient_consent: patient_consent_order_by
  patient_id: order_by
  questionnaire_responses_aggregate: questionnaire_response_aggregate_order_by
  updated_at: order_by
  user: user_order_by
  userByCreatedBy: user_order_by
  userByFirstViewedBy: user_order_by
  userByLastActivityBy: user_order_by
  workflow_status: order_by
}

"""primary key columns input for table: patient_record"""
input patient_record_pk_columns_input {
  id: uuid!
}

"""
select columns of table "patient_record"
"""
enum patient_record_select_column {
  """column name"""
  assigned_to
  """column name"""
  created_at
  """column name"""
  created_by
  """column name"""
  deleted_at
  """column name"""
  first_viewed_at
  """column name"""
  first_viewed_by
  """column name"""
  id
  """column name"""
  invite_expires_at
  """column name"""
  invite_status
  """column name"""
  invite_token
  """column name"""
  last_activity_at
  """column name"""
  last_activity_by
  """column name"""
  notes
  """column name"""
  organization_id
  """column name"""
  patient_id
  """column name"""
  updated_at
  """column name"""
  workflow_status
}

"""
input type for updating data in table "patient_record"
"""
input patient_record_set_input {
  assigned_to: uuid
  created_at: timestamptz
  created_by: uuid
  deleted_at: timestamptz
  first_viewed_at: timestamptz
  first_viewed_by: uuid
  id: uuid
  invite_expires_at: timestamptz
  invite_status: String
  invite_token: uuid
  last_activity_at: timestamptz
  last_activity_by: uuid
  notes: String
  organization_id: uuid
  patient_id: uuid
  updated_at: timestamptz
  workflow_status: String
}

"""
Streaming cursor of the table "patient_record"
"""
input patient_record_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: patient_record_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input patient_record_stream_cursor_value_input {
  assigned_to: uuid
  created_at: timestamptz
  created_by: uuid
  deleted_at: timestamptz
  first_viewed_at: timestamptz
  first_viewed_by: uuid
  id: uuid
  invite_expires_at: timestamptz
  invite_status: String
  invite_token: uuid
  last_activity_at: timestamptz
  last_activity_by: uuid
  notes: String
  organization_id: uuid
  patient_id: uuid
  updated_at: timestamptz
  workflow_status: String
}

"""
update columns of table "patient_record"
"""
enum patient_record_update_column {
  """column name"""
  assigned_to
  """column name"""
  created_at
  """column name"""
  created_by
  """column name"""
  deleted_at
  """column name"""
  first_viewed_at
  """column name"""
  first_viewed_by
  """column name"""
  id
  """column name"""
  invite_expires_at
  """column name"""
  invite_status
  """column name"""
  invite_token
  """column name"""
  last_activity_at
  """column name"""
  last_activity_by
  """column name"""
  notes
  """column name"""
  organization_id
  """column name"""
  patient_id
  """column name"""
  updated_at
  """column name"""
  workflow_status
}

input patient_record_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: patient_record_set_input
  """filter the rows which have to be updated"""
  where: patient_record_bool_exp!
}

"""
select columns of table "patient"
"""
enum patient_select_column {
  """column name"""
  clinic_internal_id
  """column name"""
  created_at
  """column name"""
  date_of_birth_encrypted
  """column name"""
  deleted_at
  """column name"""
  first_name_encrypted
  """column name"""
  gender_encrypted
  """column name"""
  id
  """column name"""
  last_name_encrypted
  """column name"""
  organization_id
  """column name"""
  updated_at
}

"""
input type for updating data in table "patient"
"""
input patient_set_input {
  clinic_internal_id: String
  created_at: timestamptz
  date_of_birth_encrypted: String
  deleted_at: timestamptz
  first_name_encrypted: String
  gender_encrypted: String
  id: uuid
  last_name_encrypted: String
  organization_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "patient"
"""
input patient_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: patient_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input patient_stream_cursor_value_input {
  clinic_internal_id: String
  created_at: timestamptz
  date_of_birth_encrypted: String
  deleted_at: timestamptz
  first_name_encrypted: String
  gender_encrypted: String
  id: uuid
  last_name_encrypted: String
  organization_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "patient"
"""
enum patient_update_column {
  """column name"""
  clinic_internal_id
  """column name"""
  created_at
  """column name"""
  date_of_birth_encrypted
  """column name"""
  deleted_at
  """column name"""
  first_name_encrypted
  """column name"""
  gender_encrypted
  """column name"""
  id
  """column name"""
  last_name_encrypted
  """column name"""
  organization_id
  """column name"""
  updated_at
}

input patient_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: patient_set_input
  """filter the rows which have to be updated"""
  where: patient_bool_exp!
}

type query_root {
  """
  fetch data from the table: "organization"
  """
  organization(
    """distinct select on columns"""
    distinct_on: [organization_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [organization_order_by!]
    """filter the rows returned"""
    where: organization_bool_exp
  ): [organization!]!
  """
  fetch aggregated fields from the table: "organization"
  """
  organization_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [organization_order_by!]
    """filter the rows returned"""
    where: organization_bool_exp
  ): organization_aggregate!
  """fetch data from the table: "organization" using primary key columns"""
  organization_by_pk(id: uuid!): organization
  """
  fetch data from the table: "patient"
  """
  patient(
    """distinct select on columns"""
    distinct_on: [patient_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_order_by!]
    """filter the rows returned"""
    where: patient_bool_exp
  ): [patient!]!
  """
  fetch aggregated fields from the table: "patient"
  """
  patient_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_order_by!]
    """filter the rows returned"""
    where: patient_bool_exp
  ): patient_aggregate!
  """fetch data from the table: "patient" using primary key columns"""
  patient_by_pk(id: uuid!): patient
  """
  fetch data from the table: "patient_consent"
  """
  patient_consent(
    """distinct select on columns"""
    distinct_on: [patient_consent_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_consent_order_by!]
    """filter the rows returned"""
    where: patient_consent_bool_exp
  ): [patient_consent!]!
  """
  fetch aggregated fields from the table: "patient_consent"
  """
  patient_consent_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_consent_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_consent_order_by!]
    """filter the rows returned"""
    where: patient_consent_bool_exp
  ): patient_consent_aggregate!
  """fetch data from the table: "patient_consent" using primary key columns"""
  patient_consent_by_pk(id: uuid!): patient_consent
  """
  fetch data from the table: "patient_record"
  """
  patient_record(
    """distinct select on columns"""
    distinct_on: [patient_record_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_record_order_by!]
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): [patient_record!]!
  """
  fetch aggregated fields from the table: "patient_record"
  """
  patient_record_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_record_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_record_order_by!]
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): patient_record_aggregate!
  """fetch data from the table: "patient_record" using primary key columns"""
  patient_record_by_pk(id: uuid!): patient_record
  """
  fetch data from the table: "questionnaire_response"
  """
  questionnaire_response(
    """distinct select on columns"""
    distinct_on: [questionnaire_response_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [questionnaire_response_order_by!]
    """filter the rows returned"""
    where: questionnaire_response_bool_exp
  ): [questionnaire_response!]!
  """
  fetch aggregated fields from the table: "questionnaire_response"
  """
  questionnaire_response_aggregate(
    """distinct select on columns"""
    distinct_on: [questionnaire_response_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [questionnaire_response_order_by!]
    """filter the rows returned"""
    where: questionnaire_response_bool_exp
  ): questionnaire_response_aggregate!
  """
  fetch data from the table: "questionnaire_response" using primary key columns
  """
  questionnaire_response_by_pk(id: uuid!): questionnaire_response
  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [user_order_by!]
    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!
  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [user_order_by!]
    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!
  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: String!): user
}

"""
columns and relationships of "questionnaire_response"
"""
type questionnaire_response {
  created_at: timestamptz
  deleted_at: timestamptz
  fhir_resource(
    """JSON select path"""
    path: String
  ): jsonb!
  id: uuid!
  """An object relationship"""
  organization: organization!
  organization_id: uuid!
  """An object relationship"""
  patient_consent: patient_consent!
  patient_consent_id: uuid!
  """An object relationship"""
  patient_record: patient_record!
  patient_record_id: uuid!
  submitted_at: timestamptz
  updated_at: timestamptz
}

"""
aggregated selection of "questionnaire_response"
"""
type questionnaire_response_aggregate {
  aggregate: questionnaire_response_aggregate_fields
  nodes: [questionnaire_response!]!
}

input questionnaire_response_aggregate_bool_exp {
  count: questionnaire_response_aggregate_bool_exp_count
}

input questionnaire_response_aggregate_bool_exp_count {
  arguments: [questionnaire_response_select_column!]
  distinct: Boolean
  filter: questionnaire_response_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "questionnaire_response"
"""
type questionnaire_response_aggregate_fields {
  count(columns: [questionnaire_response_select_column!], distinct: Boolean): Int!
  max: questionnaire_response_max_fields
  min: questionnaire_response_min_fields
}

"""
order by aggregate values of table "questionnaire_response"
"""
input questionnaire_response_aggregate_order_by {
  count: order_by
  max: questionnaire_response_max_order_by
  min: questionnaire_response_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input questionnaire_response_append_input {
  fhir_resource: jsonb
}

"""
input type for inserting array relation for remote table "questionnaire_response"
"""
input questionnaire_response_arr_rel_insert_input {
  data: [questionnaire_response_insert_input!]!
  """upsert condition"""
  on_conflict: questionnaire_response_on_conflict
}

"""
Boolean expression to filter rows from the table "questionnaire_response". All fields are combined with a logical 'AND'.
"""
input questionnaire_response_bool_exp {
  _and: [questionnaire_response_bool_exp!]
  _not: questionnaire_response_bool_exp
  _or: [questionnaire_response_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  fhir_resource: jsonb_comparison_exp
  id: uuid_comparison_exp
  organization: organization_bool_exp
  organization_id: uuid_comparison_exp
  patient_consent: patient_consent_bool_exp
  patient_consent_id: uuid_comparison_exp
  patient_record: patient_record_bool_exp
  patient_record_id: uuid_comparison_exp
  submitted_at: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "questionnaire_response"
"""
enum questionnaire_response_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  questionnaire_response_pkey
  """
  unique or primary key constraint on columns "patient_record_id"
  """
  uk_response_per_questionnaire_record
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input questionnaire_response_delete_at_path_input {
  fhir_resource: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input questionnaire_response_delete_elem_input {
  fhir_resource: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input questionnaire_response_delete_key_input {
  fhir_resource: String
}

"""
input type for inserting data into table "questionnaire_response"
"""
input questionnaire_response_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  fhir_resource: jsonb
  id: uuid
  organization: organization_obj_rel_insert_input
  organization_id: uuid
  patient_consent: patient_consent_obj_rel_insert_input
  patient_consent_id: uuid
  patient_record: patient_record_obj_rel_insert_input
  patient_record_id: uuid
  submitted_at: timestamptz
  updated_at: timestamptz
}

"""aggregate max on columns"""
type questionnaire_response_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  organization_id: uuid
  patient_consent_id: uuid
  patient_record_id: uuid
  submitted_at: timestamptz
  updated_at: timestamptz
}

"""
order by max() on columns of table "questionnaire_response"
"""
input questionnaire_response_max_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  organization_id: order_by
  patient_consent_id: order_by
  patient_record_id: order_by
  submitted_at: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type questionnaire_response_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  organization_id: uuid
  patient_consent_id: uuid
  patient_record_id: uuid
  submitted_at: timestamptz
  updated_at: timestamptz
}

"""
order by min() on columns of table "questionnaire_response"
"""
input questionnaire_response_min_order_by {
  created_at: order_by
  deleted_at: order_by
  id: order_by
  organization_id: order_by
  patient_consent_id: order_by
  patient_record_id: order_by
  submitted_at: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "questionnaire_response"
"""
type questionnaire_response_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [questionnaire_response!]!
}

"""
on_conflict condition type for table "questionnaire_response"
"""
input questionnaire_response_on_conflict {
  constraint: questionnaire_response_constraint!
  update_columns: [questionnaire_response_update_column!]! = []
  where: questionnaire_response_bool_exp
}

"""Ordering options when selecting data from "questionnaire_response"."""
input questionnaire_response_order_by {
  created_at: order_by
  deleted_at: order_by
  fhir_resource: order_by
  id: order_by
  organization: organization_order_by
  organization_id: order_by
  patient_consent: patient_consent_order_by
  patient_consent_id: order_by
  patient_record: patient_record_order_by
  patient_record_id: order_by
  submitted_at: order_by
  updated_at: order_by
}

"""primary key columns input for table: questionnaire_response"""
input questionnaire_response_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input questionnaire_response_prepend_input {
  fhir_resource: jsonb
}

"""
select columns of table "questionnaire_response"
"""
enum questionnaire_response_select_column {
  """column name"""
  created_at
  """column name"""
  deleted_at
  """column name"""
  fhir_resource
  """column name"""
  id
  """column name"""
  organization_id
  """column name"""
  patient_consent_id
  """column name"""
  patient_record_id
  """column name"""
  submitted_at
  """column name"""
  updated_at
}

"""
input type for updating data in table "questionnaire_response"
"""
input questionnaire_response_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  fhir_resource: jsonb
  id: uuid
  organization_id: uuid
  patient_consent_id: uuid
  patient_record_id: uuid
  submitted_at: timestamptz
  updated_at: timestamptz
}

"""
Streaming cursor of the table "questionnaire_response"
"""
input questionnaire_response_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: questionnaire_response_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input questionnaire_response_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  fhir_resource: jsonb
  id: uuid
  organization_id: uuid
  patient_consent_id: uuid
  patient_record_id: uuid
  submitted_at: timestamptz
  updated_at: timestamptz
}

"""
update columns of table "questionnaire_response"
"""
enum questionnaire_response_update_column {
  """column name"""
  created_at
  """column name"""
  deleted_at
  """column name"""
  fhir_resource
  """column name"""
  id
  """column name"""
  organization_id
  """column name"""
  patient_consent_id
  """column name"""
  patient_record_id
  """column name"""
  submitted_at
  """column name"""
  updated_at
}

input questionnaire_response_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: questionnaire_response_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: questionnaire_response_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: questionnaire_response_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: questionnaire_response_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: questionnaire_response_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: questionnaire_response_set_input
  """filter the rows which have to be updated"""
  where: questionnaire_response_bool_exp!
}

type subscription_root {
  """
  fetch data from the table: "organization"
  """
  organization(
    """distinct select on columns"""
    distinct_on: [organization_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [organization_order_by!]
    """filter the rows returned"""
    where: organization_bool_exp
  ): [organization!]!
  """
  fetch aggregated fields from the table: "organization"
  """
  organization_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [organization_order_by!]
    """filter the rows returned"""
    where: organization_bool_exp
  ): organization_aggregate!
  """fetch data from the table: "organization" using primary key columns"""
  organization_by_pk(id: uuid!): organization
  """
  fetch data from the table in a streaming manner: "organization"
  """
  organization_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [organization_stream_cursor_input]!
    """filter the rows returned"""
    where: organization_bool_exp
  ): [organization!]!
  """
  fetch data from the table: "patient"
  """
  patient(
    """distinct select on columns"""
    distinct_on: [patient_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_order_by!]
    """filter the rows returned"""
    where: patient_bool_exp
  ): [patient!]!
  """
  fetch aggregated fields from the table: "patient"
  """
  patient_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_order_by!]
    """filter the rows returned"""
    where: patient_bool_exp
  ): patient_aggregate!
  """fetch data from the table: "patient" using primary key columns"""
  patient_by_pk(id: uuid!): patient
  """
  fetch data from the table: "patient_consent"
  """
  patient_consent(
    """distinct select on columns"""
    distinct_on: [patient_consent_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_consent_order_by!]
    """filter the rows returned"""
    where: patient_consent_bool_exp
  ): [patient_consent!]!
  """
  fetch aggregated fields from the table: "patient_consent"
  """
  patient_consent_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_consent_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_consent_order_by!]
    """filter the rows returned"""
    where: patient_consent_bool_exp
  ): patient_consent_aggregate!
  """fetch data from the table: "patient_consent" using primary key columns"""
  patient_consent_by_pk(id: uuid!): patient_consent
  """
  fetch data from the table in a streaming manner: "patient_consent"
  """
  patient_consent_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [patient_consent_stream_cursor_input]!
    """filter the rows returned"""
    where: patient_consent_bool_exp
  ): [patient_consent!]!
  """
  fetch data from the table: "patient_record"
  """
  patient_record(
    """distinct select on columns"""
    distinct_on: [patient_record_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_record_order_by!]
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): [patient_record!]!
  """
  fetch aggregated fields from the table: "patient_record"
  """
  patient_record_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_record_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_record_order_by!]
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): patient_record_aggregate!
  """fetch data from the table: "patient_record" using primary key columns"""
  patient_record_by_pk(id: uuid!): patient_record
  """
  fetch data from the table in a streaming manner: "patient_record"
  """
  patient_record_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [patient_record_stream_cursor_input]!
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): [patient_record!]!
  """
  fetch data from the table in a streaming manner: "patient"
  """
  patient_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [patient_stream_cursor_input]!
    """filter the rows returned"""
    where: patient_bool_exp
  ): [patient!]!
  """
  fetch data from the table: "questionnaire_response"
  """
  questionnaire_response(
    """distinct select on columns"""
    distinct_on: [questionnaire_response_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [questionnaire_response_order_by!]
    """filter the rows returned"""
    where: questionnaire_response_bool_exp
  ): [questionnaire_response!]!
  """
  fetch aggregated fields from the table: "questionnaire_response"
  """
  questionnaire_response_aggregate(
    """distinct select on columns"""
    distinct_on: [questionnaire_response_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [questionnaire_response_order_by!]
    """filter the rows returned"""
    where: questionnaire_response_bool_exp
  ): questionnaire_response_aggregate!
  """
  fetch data from the table: "questionnaire_response" using primary key columns
  """
  questionnaire_response_by_pk(id: uuid!): questionnaire_response
  """
  fetch data from the table in a streaming manner: "questionnaire_response"
  """
  questionnaire_response_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [questionnaire_response_stream_cursor_input]!
    """filter the rows returned"""
    where: questionnaire_response_bool_exp
  ): [questionnaire_response!]!
  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [user_order_by!]
    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!
  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [user_order_by!]
    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!
  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: String!): user
  """
  fetch data from the table in a streaming manner: "user"
  """
  user_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [user_stream_cursor_input]!
    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "user"
"""
type user {
  app_uuid: uuid
  createdAt: timestamp!
  deletedAt: timestamp
  email: String!
  emailVerified: Boolean!
  firstName: String
  id: String!
  image: String
  isActive: Boolean
  isAnonymous: Boolean
  lastName: String
  name: String!
  """An object relationship"""
  organization: organization
  organizationId: uuid
  """An array relationship"""
  patientRecordsByCreatedBy(
    """distinct select on columns"""
    distinct_on: [patient_record_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_record_order_by!]
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): [patient_record!]!
  """An aggregate relationship"""
  patientRecordsByCreatedBy_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_record_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_record_order_by!]
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): patient_record_aggregate!
  """An array relationship"""
  patientRecordsByFirstViewedBy(
    """distinct select on columns"""
    distinct_on: [patient_record_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_record_order_by!]
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): [patient_record!]!
  """An aggregate relationship"""
  patientRecordsByFirstViewedBy_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_record_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_record_order_by!]
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): patient_record_aggregate!
  """An array relationship"""
  patientRecordsByLastActivityBy(
    """distinct select on columns"""
    distinct_on: [patient_record_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_record_order_by!]
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): [patient_record!]!
  """An aggregate relationship"""
  patientRecordsByLastActivityBy_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_record_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_record_order_by!]
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): patient_record_aggregate!
  """An array relationship"""
  patient_records(
    """distinct select on columns"""
    distinct_on: [patient_record_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_record_order_by!]
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): [patient_record!]!
  """An aggregate relationship"""
  patient_records_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_record_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [patient_record_order_by!]
    """filter the rows returned"""
    where: patient_record_bool_exp
  ): patient_record_aggregate!
  roles(
    """JSON select path"""
    path: String
  ): jsonb
  updatedAt: timestamp!
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

input user_aggregate_bool_exp {
  bool_and: user_aggregate_bool_exp_bool_and
  bool_or: user_aggregate_bool_exp_bool_or
  count: user_aggregate_bool_exp_count
}

input user_aggregate_bool_exp_bool_and {
  arguments: user_select_column_user_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: user_bool_exp
  predicate: Boolean_comparison_exp!
}

input user_aggregate_bool_exp_bool_or {
  arguments: user_select_column_user_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: user_bool_exp
  predicate: Boolean_comparison_exp!
}

input user_aggregate_bool_exp_count {
  arguments: [user_select_column!]
  distinct: Boolean
  filter: user_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  count(columns: [user_select_column!], distinct: Boolean): Int!
  max: user_max_fields
  min: user_min_fields
}

"""
order by aggregate values of table "user"
"""
input user_aggregate_order_by {
  count: order_by
  max: user_max_order_by
  min: user_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input user_append_input {
  roles: jsonb
}

"""
input type for inserting array relation for remote table "user"
"""
input user_arr_rel_insert_input {
  data: [user_insert_input!]!
  """upsert condition"""
  on_conflict: user_on_conflict
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  app_uuid: uuid_comparison_exp
  createdAt: timestamp_comparison_exp
  deletedAt: timestamp_comparison_exp
  email: String_comparison_exp
  emailVerified: Boolean_comparison_exp
  firstName: String_comparison_exp
  id: String_comparison_exp
  image: String_comparison_exp
  isActive: Boolean_comparison_exp
  isAnonymous: Boolean_comparison_exp
  lastName: String_comparison_exp
  name: String_comparison_exp
  organization: organization_bool_exp
  organizationId: uuid_comparison_exp
  patientRecordsByCreatedBy: patient_record_bool_exp
  patientRecordsByCreatedBy_aggregate: patient_record_aggregate_bool_exp
  patientRecordsByFirstViewedBy: patient_record_bool_exp
  patientRecordsByFirstViewedBy_aggregate: patient_record_aggregate_bool_exp
  patientRecordsByLastActivityBy: patient_record_bool_exp
  patientRecordsByLastActivityBy_aggregate: patient_record_aggregate_bool_exp
  patient_records: patient_record_bool_exp
  patient_records_aggregate: patient_record_aggregate_bool_exp
  roles: jsonb_comparison_exp
  updatedAt: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """
  unique or primary key constraint on columns "app_uuid"
  """
  user_app_uuid_key
  """
  unique or primary key constraint on columns "email"
  """
  user_email_key
  """
  unique or primary key constraint on columns "id"
  """
  user_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input user_delete_at_path_input {
  roles: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input user_delete_elem_input {
  roles: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input user_delete_key_input {
  roles: String
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  app_uuid: uuid
  createdAt: timestamp
  deletedAt: timestamp
  email: String
  emailVerified: Boolean
  firstName: String
  id: String
  image: String
  isActive: Boolean
  isAnonymous: Boolean
  lastName: String
  name: String
  organization: organization_obj_rel_insert_input
  organizationId: uuid
  patientRecordsByCreatedBy: patient_record_arr_rel_insert_input
  patientRecordsByFirstViewedBy: patient_record_arr_rel_insert_input
  patientRecordsByLastActivityBy: patient_record_arr_rel_insert_input
  patient_records: patient_record_arr_rel_insert_input
  roles: jsonb
  updatedAt: timestamp
}

"""aggregate max on columns"""
type user_max_fields {
  app_uuid: uuid
  createdAt: timestamp
  deletedAt: timestamp
  email: String
  firstName: String
  id: String
  image: String
  lastName: String
  name: String
  organizationId: uuid
  updatedAt: timestamp
}

"""
order by max() on columns of table "user"
"""
input user_max_order_by {
  app_uuid: order_by
  createdAt: order_by
  deletedAt: order_by
  email: order_by
  firstName: order_by
  id: order_by
  image: order_by
  lastName: order_by
  name: order_by
  organizationId: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type user_min_fields {
  app_uuid: uuid
  createdAt: timestamp
  deletedAt: timestamp
  email: String
  firstName: String
  id: String
  image: String
  lastName: String
  name: String
  organizationId: uuid
  updatedAt: timestamp
}

"""
order by min() on columns of table "user"
"""
input user_min_order_by {
  app_uuid: order_by
  createdAt: order_by
  deletedAt: order_by
  email: order_by
  firstName: order_by
  id: order_by
  image: order_by
  lastName: order_by
  name: order_by
  organizationId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!
  """upsert condition"""
  on_conflict: user_on_conflict
}

"""
on_conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]! = []
  where: user_bool_exp
}

"""Ordering options when selecting data from "user"."""
input user_order_by {
  app_uuid: order_by
  createdAt: order_by
  deletedAt: order_by
  email: order_by
  emailVerified: order_by
  firstName: order_by
  id: order_by
  image: order_by
  isActive: order_by
  isAnonymous: order_by
  lastName: order_by
  name: order_by
  organization: organization_order_by
  organizationId: order_by
  patientRecordsByCreatedBy_aggregate: patient_record_aggregate_order_by
  patientRecordsByFirstViewedBy_aggregate: patient_record_aggregate_order_by
  patientRecordsByLastActivityBy_aggregate: patient_record_aggregate_order_by
  patient_records_aggregate: patient_record_aggregate_order_by
  roles: order_by
  updatedAt: order_by
}

"""primary key columns input for table: user"""
input user_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input user_prepend_input {
  roles: jsonb
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  app_uuid
  """column name"""
  createdAt
  """column name"""
  deletedAt
  """column name"""
  email
  """column name"""
  emailVerified
  """column name"""
  firstName
  """column name"""
  id
  """column name"""
  image
  """column name"""
  isActive
  """column name"""
  isAnonymous
  """column name"""
  lastName
  """column name"""
  name
  """column name"""
  organizationId
  """column name"""
  roles
  """column name"""
  updatedAt
}

"""
select "user_aggregate_bool_exp_bool_and_arguments_columns" columns of table "user"
"""
enum user_select_column_user_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  emailVerified
  """column name"""
  isActive
  """column name"""
  isAnonymous
}

"""
select "user_aggregate_bool_exp_bool_or_arguments_columns" columns of table "user"
"""
enum user_select_column_user_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  emailVerified
  """column name"""
  isActive
  """column name"""
  isAnonymous
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  app_uuid: uuid
  createdAt: timestamp
  deletedAt: timestamp
  email: String
  emailVerified: Boolean
  firstName: String
  id: String
  image: String
  isActive: Boolean
  isAnonymous: Boolean
  lastName: String
  name: String
  organizationId: uuid
  roles: jsonb
  updatedAt: timestamp
}

"""
Streaming cursor of the table "user"
"""
input user_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_stream_cursor_value_input {
  app_uuid: uuid
  createdAt: timestamp
  deletedAt: timestamp
  email: String
  emailVerified: Boolean
  firstName: String
  id: String
  image: String
  isActive: Boolean
  isAnonymous: Boolean
  lastName: String
  name: String
  organizationId: uuid
  roles: jsonb
  updatedAt: timestamp
}

"""
update columns of table "user"
"""
enum user_update_column {
  """column name"""
  app_uuid
  """column name"""
  createdAt
  """column name"""
  deletedAt
  """column name"""
  email
  """column name"""
  emailVerified
  """column name"""
  firstName
  """column name"""
  id
  """column name"""
  image
  """column name"""
  isActive
  """column name"""
  isAnonymous
  """column name"""
  lastName
  """column name"""
  name
  """column name"""
  organizationId
  """column name"""
  roles
  """column name"""
  updatedAt
}

input user_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: user_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: user_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: user_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: user_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: user_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: user_set_input
  """filter the rows which have to be updated"""
  where: user_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}